3306
33060
admin
service MySQL80

root

--------------------------
-------- LESSON 1 --------
--------------------------

mysql -u root -h 192.168.0.10 -P 3306 

USE    \u выбор базы данных
SOURCE \. Выполнение sql-команды из файла
SYSTEM \! Выполнение команды операционной системы
STATUS \s Вывод информации о состоянии сервера
EXIT   \q выход
       \G вывод результата в вертикальном формате

SOURCE hello.sql -- выполнение файла hello.sql

Файл с учеткой для автоматического подключения
-----
my.cnf
[client]
user=admin
password=admin

mysqldump mysql > mysql.sql -- экспорт базы данных mysql в файл mysql.sql
mysql mysql < mysql.sql -- импорт данных из mysql.sql в базу данных mysql

CREATE DATABASE shop CHARACTER SET utf8 COLLATE utf8_general_ci;
drop database shop;

create database shop;
show databases;
show variables like 'datadir';
drop database shop;
create database if not exists shop;
use shop
show tables;
show tables from mysql; -- указали базу данных mysql
select mysql.User.User, mysql.User.Host from mysql.User; -- запрос с квалифицированными именами
mysql shop; -- подключение с одновременным указанием базы данных

create table users (k int);
create table if not exists users (k int);
describe users; -- просмотр структуры таблицы
describe user 'User'; -- оператору можно указать имя столбца
describe user 'm%'; -- можно указывать шаблоны для сталбцов '_', '%'

SELECT * FROM information_schema.SCHEMATA;

select * from information_schema.TABLES where table_schema = 'shop';


--------------------
---------ДЗ LESSON 1
--------------------

Задание 2
create database example;
create table users(id int, name text);
mysqldump example > example.sql
create database sample
mysql sample < exmaple.sql

Задание 3
mysqldump --where="1 limit 100" mysql help_keyword > help_keyword.sql


----Разбор домашки
-------------------

create table if not exists users (
    id SERIAL COMMENT 'Table primary key', -- BigInt, первичный ключ, автоинкремент
    name VARCHAR(255) COMMENT 'User name'
);


SHOW CREATE TABLE users

SOURCE example.sql

mysqldump --skip-opt --where="1 limit 100" mysql help_keyword > help_keyword.sql    // --skip-opt - сделает несколько insert-ов вместо одного




--------------------------
-------- LESSON 2 --------
--------------------------

Типы данных
TINYINT   1 byte
SMALLINT  2 byte
MEDIUMINT 3 byte
INT       4 byte
BIGINT    8 byte

Вещественные
FLOAT  4 byte 
DOUBLE 8 byte
DECIMAL -- более точный тип. обрабатывается дольше всех типов. Число хранится в виде строки. Тип без потери точности

CREATE TABLE tbl(id INT(8)) -- 8 - указывает сколько символов печатать в консоле. необязательный параметр
'       5' -- пример печати в консоле

CREATE TABLE tbl(id INT(8) ZEROFILL)
'00000005' -- пример печати в консоле

DECIMAL(7,4) -- под число отводится 7 байт, а под дробную часть 4 байта

CREATE TABLE tbl (price DECIMAL(7,4));


Строковые типы:
CHAR - фиксированная длина

VARCHAR - переменная длина строки, в скобках указвается максимальная длина строки. Максимальная длина 65536

BLOB
TINYTEXT   2 ^  8 = 256
TEXT       2 ^ 16 = 65536 
MEDIUMTEXT 2 ^ 24 = 16777216(16Mb)
LONGTEXT   2 ^ 32 = 4294967296(4Gb)

create table tbl (
    name char(10) default 'anonymous',
    description varchar(255)
);
insert into tbl values (default, 'New user');
insert into tbl values ('Игорь', 'New user');

ALT+X - выполнить скрипт в dbeaver



Тип NULL
    Все операции с данным типом приводят к типу NULL


create table tbl (id int unsigned);
alter table tbl change id id int unsigned not null;
truncate tbl;


Каледнарные типы даннх:                                                               
YEAR - хранит год                                                                   1 byte 0000
DATE - хранит дату с точностю до дня                                                3 byte 0000-00-00
TIME - для хранения времени в течение суток                                         3 byte 00:00:00
TIMESTAMP - также хранит дату и время. занимает в 2 раза меньше                     4 byte 0000-00-00 00:00:00
   места чем DATETIME, но может хранить даты в ограниченном интевале от 1970-2038гг   
DATETIME - хранит дату и время                                                      8 byte 0000-00-00 00:00:00


select '2018-10-01 0:00:00' - interval 1 day; -- вычли из даты 1 день
select '2018-10-01 0:00:00' + interval 1 week; -- прибавили 1 неделю к дате 
select '2018-10-01 0:00:00' + interval 1 year; -- прибавили 1 год к дате 

комбинированные интервалы
select '2018-10-01 0:00:00' + interval '1-1' year_month; -- прибавили 1 год и 1 месяц к дате 

Enum и Set типы данных
При создании столбца данного тип значения задаются строковым списком через запятую 'first', 'second', 'third', но значения в столбце хранятся в виде чисел.

alter table tbl add collect json;
insert into tbl values (1, '{"first":"Hello", "second":"World"}'); -- вставка json Объекта
select collect->>"$.first" from tbl; -- получение значения поля json Объекта



Типы индексов:
Обычные - может быть несколько
уникальные, первичные - может быть в таблице только один. в строках данного столбца могут храниться только уникальные данные. значения не могут принимать NULL
полнотекстовые - предназначен для столбцов типа text, позволяющий проводить полнотекстовый поиск. На практике же полнотекстовый поиск осуществляется субд ElasticSearch


Включение механизма auto_increment
insert into catalogs (name) values ('Processors');
insert into catalogs values (NULL, 'Motherboards');
insert into catalogs values (0, 'Video cards');
insert into catalogs values (default, 'Video cards');


Псевдотип SERIAL
SERIAL == BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE

Mysql поддерживает 2 тип индексов BTREE и хэштаблицу


CRUD ОПЕРАЦИИ
--------------
DELETE FROM catalogs;
TRUNCATE catalogs; -- очищает таблицу и обнуляет счетчики auto_increment



--------------------------
-------- LESSON 3 --------
--------------------------

'5' + '2' = 7
5 div 2 = 2 -- целочисленное деление
5 % 2 = 1 -- остаток от деления
5 mod 2 = 1 -- остаток от деления
true и false -- костанты. тип tinyint 1 и 0 соотвественно
<=> -- безопасное сравнение, позволяет сравнивать со значением NULL, nlow
not, ! -- отрицание
2 = NULL -- NULL
2 != NULL -- NULL
2 <=> NULL -- 0
NULL <=> NULL -- 1

create table tbl (
    x int,
    y int,
    summ int as (x + y) -- вычислется при обращении, не сохраняется на диске
);


create table tbl (
    x int,
    y int,
    summ int as (x + y) stored  -- сохраеяется на диске, более того, мы можем его индексировать
);

between 1 and 100
not between 10 and 70

select 2 in (0, null, 5, 'str') -- null
not in 

\% -- чтобы вывести %
\_ -- чтобы вывести _



RLIKE или REGEXP -- регулярные выражения

LIMIT 3, 4 -- 3 - позиция, начиная с которой необходимо вернуть результат, 4 - количество извлекаемых записей
LIMIT 4 OFFSET 3 -- тоже самоей

select distinct catalog_id from products order by catalog_id


----
---- МЕТОДЫ
----

NOW() -- текущее время и дата. за время запроса вычиляется только один раз, не зависимо от количества вызовов этого метода

DATE(date) -- отрезает время
DATE_FORMAT('2018-06-12 01:59:59', 'На дворе %Y год') -- на дворе 2018 год
DATE_FORMAT(birthday_at, '%d.%m.%Y') as birthday_at

UNIXSTAMP -- данный формат даты числовой, обрабатывается быстро, можно идексировать и занимает меньше места 4 байта, DATETIME - 8байт. Хранит даты от 1970 по 2038 год

UNIX_TIMESTAMP() -- преобразование в UNIXSTAMP
FROM_UNIXTIME() -- преобразование из UNIXSTAMP

SELECT UNIX_TIMESTAMP('2018-10-1O 10:09:23') AS TIMESTAMP, FROM_UNIXTIME(1539155363) AS DATETIME; -- 1539155363, 2018-10-1O 10:09:23

TO_DAYS() -- получение количесва дней 
FLOOR() -- избавление от дробной части

TIMESTAMPDIFF(YEAR, birthday_at, now()) -- более точный вариант

select * from users order by RAND() -- вывод строк в случайном порядке

VERSION() -- текущая версия MySQL сервера

LAST_INSERT_ID() -- последний id вычисленный автоинкриментом

DATABASE() -- возвращает текущую выбранную базу данных

USER() -- текущий пользователь


---------МАТЕМАТИЧЕСКИЕ ФУНКЦИИ

SQRT() -- квадратный корень числа


create table distances (
    id SERIAL PRIMARY KEY,
    x1 INT NOT NULL,
    x2 INT NOT NULL,
    y1 INT NOT NULL,
    y2 INT NOT NULL,
    distance DOUBLE AS (SQRT(POW(x1 - x2, 2) + POW(y1 -y2, 2)))
) COMMENT = 'Расстояние между двумя точками';

create table distances (
    id SERIAL PRIMARY KEY,
    a JSON NOT NULL,
    b JSON NOT NULL,
    distance DOUBLE AS (SQRT(POW(a->>'$.x' - b->>'$.x', 2)+POW(a->>'$.y' - b->>'$.y', 2)))
) COMMENT = 'Расстояние между двумя точками';


square DOUBLE AS (a * b * SIN(RADIANS(angle))/2.0)

alter table triangles change square square DOUBLE AS (ROUND(a * b * SIN(RADIANS(angle))/2.0))

ROUND() -- математическое округление
CEILING() -- округление в большую сторону 

------ СТРОКОВЫЕ ФУНКЦИИ
SUBSTRING(name, 1, 5) -- получение подстроки, 1 - позиция начала, 5 - количество извлекаемых символов
CONCAT() -- объединение строк

IF(TRUE, 'истина', 'ложь') -- функция условия

select 
    case 
        when color = 'red' then 'красный'
        when color = 'orange' then 'оранжевый'
        else 'фиолетовый'
    end


INET_ATON('62.145.69.10') -- представление IP адреса ввиде целого числа
INET_NTOA() -- решает обратную задачу

UUID() -- возвращает универсальный уникальный идетификатор


--------------------------
-------- LESSON 4 --------
--------------------------

GROUP_CONCAT(column name) -- показывает какие значения попали в группу. Может извлечь максимум 1000 элементов, но можно изменить с помощью параметра сервера GROUP_CONCAT_MAX_LEN 
GROUP_CONCAT(name SEPARATOR ' ') -- позволяет указать заделитель
GROUP_CONCAT(name ORDER BY name DESC SEPARATOR ' ') -- позволяет добавить сортировку значений

COUNT(column) -- исключаются NULL значения
COUNT(DISTINCT catalog_id) -- исключаются повторяющиеся значения

SELECT * FROM users HAVING birthday_at >= '1990-01-01'; -- можно использовать HAVING без GROUP BY. В этом случае каждая строка рассматривается как отдельная группа

ANY_VALUE() -- возвращает случайное значение группового поля

WITH ROLLUP -- для подведения итогов по сгруппированным данным.

CONCAT_WS('-', 2019,  10, 31); -- 2019-10-31


--------------------------
-------- LESSON 5 --------
--------------------------
Типы многотабличных запросов
- объединения (union)
- вложенные запросы 
- соединение (join)

1) Опрерации над множествами
- union (поддержано MYSQL)
- except - разность
- intersect - пересечение

2) Вложенные запросы
select id, <SUBQUERY> from <SUBQUERY> where <SUBQUERY> group by id having <SUBQUERY>

3) Тип JOIN соединений
- join (inner join)
- left join - справа допускаются NULL
- right join - слева допускаются NULL
- outer join (неподдержано MYSQL)


UNION (ALL OR distinct)
ORDER BY действует на весь результат запроса с оператором UNION, а не на отдельные таблицы
Для LIMIT выполняется тоже самое
Это можно обойти с помощью вложенных запросов, например
(select name from catalogs order by name desc limit 2) union all (select name from rubrics order by name desc limit 2)
Первый SELECT запрос определяет название стобцов
UNION запросы выполняются долго. Почти всегда промежуточная таблица размещается на жестком диске, следовательно сортировка и фильтрация также будет выполняться во временном файле. Следует указвать только необходимые стоблы в запросе. Чем меньше столбцов, тем меньше размер промежуточной таблицы и тем быстрее проходят операции с ней.


Кореллированный запрос - если вложенный запрос использует столбец из внешнего запроса. Субд вынуждена вычислять подзапрос для каждой строки запроса, что может быть накладно для объемных таблиц.

Если подзапрос возвращает более одного результата, то будет ошибка. В таких случаях можно использовать например оператор IN (это оператор равенства в отношении множеств)

select * from products where catalog_id = 2 and price < ANY (select price from products where catalog_id = 1)


condition operator ANY или SOME - выражение считается истиным, если хотя бы одно из значений true
condition operator ALL - выражение считается истиным, если все значения true

[not] exists - используется для проверки, есть ли во вложенном запросе записи. возвращает TRUE/FALSE


MYSQL реализованы строчные запросы, т.е. подзапросы, которые возвращают более одного стоблца

select id, name, price, catalog_id from products where (catalog_id, 5060.00) in (select id, price from catalogs); -- где (catalog_id, 5060.00) - коструктор строки, его можно записывать с помощью ключевого слова RAW(catalog_id, 5060.00)

Декартово произведение
select * from tbl1, tbl2
select * from tbl1 join tbl2


select p.name, p.price, c.name from catalogs as c join products as p where c.id = p.catalog_id
select p.name, p.price, c.name from catalogs as c join products as p on c.id = p.catalog_id

Условивие в ON отрабатывает в момент соединения таблиц, т.е. промежуточная таблица сразу получается небольшой, в то время как WHERE условие действует после соединения, сначала получам декартово произведение затем выполняется фильтрация

Запросы с самообъединением таблиц - запрос в которых одна и таже таблица подключается 2 и более раз.

Когда название стоблцов таблиц по которым выполняется объединение равны, то можно вместо ON использовать USING(название стобца)
select * from catalogs as fst join catalogs as snd USING(id);


Многотабличный запрос можно использовать для обновления или удаления данных
select catalogs join products on catalogs.id = products.catalog_id set price = price * 0.9 where catalogs.name = 'Мат.платы';
delete products, catalogs from catalogs join products on catalogs.id = products.catalog_id where catalogs.name = 'Мат.платы'; -- удалятся записи из обоих таблиц
delete products from catalogs join products on catalogs.id = products.catalog_id where catalogs.name = 'Мат.платы'; -- удалятся записи только из products 

ОГРАНИЧЕНИЕ ВНЕШНЕГО КЛЮЧА

foreign key (col1, ...) references tbl (tbl_col, ...) [on delete ...] [on update ...]

cascade - удалит или обновить при изменении родителя
set null - установить в Null при удалении или обновлении родителя
no action - оставить как есть при удалении или обновлении родителя
restrict - запретить удаление, если в дочерней таблице есть записи ссылающиейся на родителя
set default - установиь DEFAULT значение при удалении или обновлении родителя

alter table products add foreign key (catalog_id) references catalogs(id) on delete no action on update no action; -- имя задастся автоматически
alter table products add constraint fk_catalog_id foreign key (catalog_id) references catalogs(id) on delete no action on update no action;
alter table products drop foreign key products_ibfk_1;

--------------------------
-------- LESSON 6 --------
--------------------------

START TRANSACTION;
ROLLBACK;   

Нельзя выполнить откат следующих команд
CREATE INDEX, DROP INDEX, CREATE TABLE, DROP TABLE, TRUNCATE TABLE, ALTER TABLE, RENAME TABLE, CREATE DATABASE, DROP DATABASE, ALTER DATABASE

Команды, которые неявно завершают транзакцию
ALTER TABLE, BEGIN, CREATE INDEX, CREATE TABLE, CREATE DATABASE, DROP DATABASE, DROP INDEX, DROP TABLE, DROP DATABASE, LOAD MASTER DATA, LOCK TABLES, RENAME, SET AUTOCOMMIT=1, START TRANSACTION, TRUNCATE TABLE

Транзакции не могу быть вложенными

SAVEPOINT
ROLLBACK TO SAVEPOINT

SET AUTOCOMMIT = 0/1 -- enable / disable autocommit.

Transactions should be ACID
- Atomicy - атомарность - все части транзакции либо одновременно выполняется, либо отменяются, т.е. нет частично выполненных транзакций
- Consistency - согласованность, БД переходит из одного непротиворечивого состояние в другое непротиворечивое состояние
- Isolation - изолированность - результат текущей транзакции не виден другим транзакция пока текущая транзакция не закончена
- Durability - сохраняемость - изменения в ходе транзакции будучи зафиксированы становятся постоянными

Уровни изоляции транзакций:
- READ UNCOMMITTED -- транзакции могут видеть результаты не зафиксированных транзакций  
- READ COMMITTED -- транзакции увидят только те изменения, которые уже были зафиксированны другими транзакциями к моменту ее начала, а произведенные ею изменения останутся не видимыми для других транзакций, пока текущая транзакция не будет зафиксированна. На этом уровне возможен феномен Невоспроизводимого чтения. Т.е можете выполнить одну и ту же команду и получить различные результаты
- REPEATABLE READ -- по умолчанию, решает проблемы предыдущих уровней Возможен Фантомного чтения
- SERIALIZABLE


SET TRANSACTION ISOLATION LEVEL READ COMMITED;

show variables like 'datadir'; -- путь к системного каталогу
ib_logfile0, ib_logfile1 -- файлы журнала транзакций

INODB - хранит все таблицы всех баз данных в едином табличном пространстве в файле ibdata1
Физически единое табличное пространство может располагаться в нескольких файлах
Можем выделить отдельные табличные пространства под каждую из таблиц

Изначальна траназкции помещаются в ib_logfile0, ib_logfile1 и затем перегоняются в ibdata1

Если происходит штатная остановка сервера, то транзакции перегоняются из ib_logfile0, ib_logfile1 в ibdata1
Если нешатно, то при следующем старте сервака, транзакции перегоняются из ib_logfile0, ib_logfile1 в ibdata1

Увеличивая размер журнала транзакций можно ускорить вставку записей при штатной работе MYSQL, однако чем больше журнал транзакций, тем медленней будет стартовать сервер

Три режима сохранения журнала транзакций innodb_flush_log_at_trx_commit:
- 0 -- сохранение журнала раз в секунду
- 1 -- сохранение после каждой транзакции
- 2 -- 0 + 1

show variables like 'innodb_flush_log_at_trx_commit';
set global innodb_flush_log_at_trx_commit = 0; -- раз в секунду


Пользоватльские переменные SQL
select @total := count(*) from products; -- создание переменной
select @total; -- обращение к переменной, будет доступна только в текущей сессии

Если в качестве значения переменной передается столбец который содержет множество значений, то переменная получит последнее значение.

Переменные могу определяться с помощью SET
set @last = now() - interval 7 day;

Можно пронумеровать строки в селекте
set @start := 0;
select @start := @start + 1 as id, name from products;

Cистемные переменные:
show variables;
show variables like 'read_buffer_size';

- GLOBAL - глобальные, влияют на весь сервер 
- SESSION - сеансовые, влияют на текуще подключение

При статре сервера происходит инициализация переменных значениями по умолчнию
set global read_buffer_size = 2097152; -- изменение глобальной переменной
set @@global.read_buffer_size = 2097152; -- изменение глобальной переменной

При подключении к серверу сеансовые переменные принимают значения заданные для глобальных переменых
set session read_buffer_size = 2097152;
set @@session.read_buffer_size = 2097152;
set read_buffer_size = DEFAULT;

Временные таблицы:
create temporary table table_name (
    id SERIAL PRIMARY KEY,
    name varchar(255),
    ...
);
Временная таблица автоматически удаляется позавершению соединения с сервером.
Ее имя действительно только в течение данного соединения
create temporary table temp (id int, name varchar(255));
Временные таблицы хранятся во временном табличном пространстве ibtmp1

Динамические запросы
prepare ver from 'select version()';
execute ver;
Живут в течение текущего сеанса
prepare prd from 'select id, name, price from products where catalog_id = ?'; -- параметризованный динамический запрос
set @catalog_id = 1;
execute prd using @catalog_id;
Есть ряд ограничений. Не допускается использование вложенным динамических запросов, а также нескольких запросов. Параметр всегда передает строку, поэтому не получится динамически задать имя таблицы или столбца
drop prepare prd; -- удаление запроса

Представления
Это запрос на выборку которому присваивается уникальное имя и который можно сохранять и удалять из БД как обычную таблицу
Более гибкое управление правами доступа к таблицам. Также можно запретить прямое обращение пользователей к таблицам и разрешить только к представлениям. Также позволяют обеспечить совместимость программ ориентирующихся на старую структуру данных
create view cat as select * from catalogs order by name;
create view cat_reverse (catalog, catalog_id) as select name, id from catalogs;
create or replace view namecat (id, name, total) as select id, name, length(name) from catalogs;

Алгоритм формирования конечного запроса
- merge - 
- temptable - результирующая таблица представления помещается во временную таблицу, которая затем используется в конечном запросе
- undefined - mysql самостоятельно выбирает алгоритм, предпочитая использовать merge и прибегает к temptable только в случае необходимости
По умолчанию используется UNDEFINED

create algorithm = temptable view cat2 as select * from catalogs;

Скрытие столбцов в таблицы в представлении такие представления называются ВЕРТИКАЛЬНЫМИ

create or replace view prod as select id, name, price, catalog_id from products order by catalog_id, name; 

select * from prod order by name desc; -- можно использовать условие в запросе с представлением


ГОРИЗОТАЛЬНЫЕ ПРЕДСТАВЛЕНИЯ -- ограничивают доступ пользователям к строкам таблицы

create or replace view processors as select id, name, price, catalog_id from products where catalog_id = 1;

На практике могут встречаться СМЕШЕННЫЕ ПРЕДСТАВЛЕНИЯ

Чтобы можно было вставлять данные в представление командой INSERT и обнавалять существующие записи командой UPDATE, необходимо при создании представления использовать конструкцию WITH CHECK OPTION. Во время вставки проверяется, чтобы вставляемые данные удовлетворяли WHERE условию запроса, лежащего в основе представления

create table tbl1 (value varchar(255));
create view v1 as select * from tbl1 where value < 'fst5' with check option;
insert into tbl1 values ('fst1'), ('fst2'), ('fst3');
insert into v1 values ('fst4');
insert into v1 values ('fst5'); -- ошибка

alter view v1 as select * from tbl1 where value > 'fst4' with check option; -- редактирование представления
либо воспозоваться create or replcace view
drop view -- удаляет представление
drop view if exists cat, cat_reverse;

--------------------------
-------- LESSON 7 --------
--------------------------
Два способа настройки сервера MySQL
-- параметры запуска, которые определяют режим сервера
-- переменные состояние, с помощью которых можно масштабировать сервер (часть может быть изменена с помощью параметров запуска)

--basedir -- место установки сервера
--datadir -- место расположения каталога данных
--log-error -- файл лога ошибок

ps aux | grep mysqld -- просмотр параметров запуска
mysqld --verbose --help

Параметры запуска можно не прописывать в строке запуска сервера, вместо этого их можно помечать в файл my.cnf, которые будут прочитаны при старте

Может располагаться в Unix:
/etc/my.cnf
/etc/mysql/my.cnf
$MYSQL_HOHE/my.cnf
[datadir]/my.cnf
~/.my.cnf

Может располагаться в Windows:
%WINDIR%\my.ini, %WINDIR%\my.cnf
C:\my.ini, C:\my.cnf
BASEDIR\my.ini, BASEDIR\my.cnf
Значение директивы --defaults-extra-file
%APPDATA%\MySQL\.mylogin.cnf
DATADIR\mysqld-auto.cnf

Параметры указываются без дифисов, т.к каждый параметр располагается на отдельной строке
# или ; -- комментарий строки
Параметры в файле называются Директивами

В файле есть секции
mysql и server -- влияют на все версии сервера
client -- влияют на все консольные утилиты

Директивы
bind-address = 127.0.0.1 -- сервер будет слушать запросы только с локальной машины
port = 3308

Чтобы директивы применились нужно перезапустить сервер
mysql.server stop
mysql.server start

В Ubuntu
service mysql stop
service mysql start
service mysql restart

В Windows перезапуск делается через сервисы MySQL80
sc stop MySQL80
sc start MySQL80

Параметры в базе можно посмотреть командой
show variables like 'date%_format'

set session tmp_table_size = 3355442; -- установка параметра в текущей сессии, действует до переподключения

set global tmp_table_size = 16777216; -- установка для всего сервера, действует до перезагрузки сервера



Журнальные файлы MySQL
-- журнал ошибок - все ошибки во время запуска, работы, остановки сервера
-- общий журнал запросов - регистрирует все выполняемые запросы
-- бинарный журнал - регистрирует все команды, которые приводят к изменению данных, используется для репликации и востановления данных. Для просмотра нужна утилита mysqlbinlob
-- журнал медленных запросов - помещаются запросы выполнение которых заняло больше значения переменной long_query_time, по умолчанию = 10сек


Журнал ошибок
---------------
show variable like 'log_error';
.\VKHARAPAEV.err
tail -20 file -- просмотр последних 20 строк
Если сервер не стартует, то нужно начинать с этого журнала

Общий журнал запросов
---------------------
show variable like 'general_log%'
Позволяет регистрировать все соединения клиентов и их sql запросы в текстовом формате
VKHARAPAEV.log
Из соображения производительности данный лог отключен
set global general_log = ON; -- включить журнал

Журнал медленных запросов
-------------------------
set global slow_query_log = ON -- включить журнал 
Запись добавляется только после выполения запроса и только когда будут сняты все блокировки
mysqldumpslow file.log

Логи можно хранить в таблицах
select * from mysql.slow_log;
select * from mysql.general_log;
Это зависит от значения системной переменной log_output
show variables like 'log_output'; -- по умолчанию - FILE
Если выставить TABLE - то будет писаться в базу данных
Возможные значения TABLE, FILE, NONE 

Бинарный журнал
-----------------
log_bin = ON
server-id = 1 --- идентификатор сервера, нужно чтобы можно было отличить один сервер от другого когда они связаны репликацией, если не указать при включеных бинарных логах, то сервер не будет стартовать
cat ON.index -- просмотр списка бинарных файлов
mysqlbinlog ON.000001 -- чтение бинарного файла


show variables like 'max_connections'; -- максимальное количество соеднинений
show processlist; -- количество текущих соединений


Права пользователей
-------------------
create user foo; -- создаем пользователя с пустым паролем
create user shop identified with sha256_password by 'pass';  -- создание пользователя с паролем
select user(); -- получение текущего пользователя
drop user; -- не закрывает автоматически соединение удаляемого пользователя
rename user shop to foo; -- переименование пользователя

grant
revoke

revoke all on *.* from 'foo'@'localhost'; -- лишает пользователя всех прав

Привилегии
ALL        INSERT
ALTER      REFERENCES
CREATE     SELECT
DELETE     SHOW DATABASES
DROP       SHOW VIEW
EXECUTE    USAGE
INDEX      GRANT OPTION

grant select, insert, delete, update on *.* to foo; -- полный доступ пользователю foo на просмотр, добавление, удаления и редактирования таблиц

Для того, чтобы назначить все привилегии сразу 
grant all on *.*  to foo; -- разрешает все операции, кроме назначения прав себе и другим пользователям
grant grant option on *.* to foo; -- за назначение прав отвечает GRANT OPTION

USAGE -- полная противоположность ALL

grant usage on *.* to foo; -- права на все таблицы всех базданных
grant usage on * to foo; -- если выбрана база (например use shop), то права на все таблицы это базы иначе как в *.*
grant usage on shop.* to foo; -- явно указана база данных. права распространяются в пределах это базы
grant usage on shop.catalogs to foo; -- явно указана база данных и через точку имя таблицы
grant select (id, name), update (name) on shop.catalogs to foo; -- привилегии на стоблцы таблицы

show grants; -- просмотр привилегий текущего пользователя

grant all on shop.* to 'foo'@'%' identified with sha256_password by 'pass' with max_connections_per_hour 10 max_queries_per_hour 1000 max_updates_per_hour 200 max_user_connections 3;

CREATE USER 'bar'@'localhost' IDENTIFIED WITH sha256_password BY 'bar' WITH MAX_QUERIES_PER_HOUR 20 MAX_UPDATES_PER_HOUR 10 MAX_CONNECTIONS_PER_HOUR 5 MAX_USER_CONNECTIONS 2;



Репликация
----------
Хранение одной и той же базы данных на нескольких машинах соединенных с помощью сети

Причины использования
-- географическое распределение - радихранения данных географически близко к пользователю, тем самым сокращая время ответа серверов
-- отказоустойчивость - система может продолжить работу при отказе некоторых ее частей, тем самым повышается доступность сервера для конечных пользователей
-- масштабирование - репликация часто используется для горизонтального масштабирования. Если база не справляется с назгрузкой, то можно использовать более мощные сервера - это Вертикальное масштабирование. Можно поставить рядом несколько одинаковых серверов и связать их с помощью репликации - это Горизонтальное масштабирование.

Как работает репликация
1) Данные записываются на один из серверов - Гланый или Master сервер. Записанные данные помещаются в бинарный журнал. При помощи репликации мы передаем содержимое бинарного журнала от одного сервера к другому
2) Подчиненные или Slave сервера получают содержимое бинарного журнала и воспроизводят его на своих базах данных. Таким образом мы получаем копии данных на одних и тех же серверах.

Репликация может масштабировать только операцию ЧТЕНИЯ. Операции записи не масштабируются. Т.е. выгода приобретается, если есть возможность раделить запросы на чтение среди нескольких серверов.


Настройка репликции
--------------------
Т.к. будет запущено 2 сервера, то понадобится два разных каталога данных

[mysqld]
user          = root
port          = 3307
datadir       = /var/lib/mysql1
socket        = /tmp/mysql1.sock
pid-file      = /var/lib/mysql1/mysqld.pid
log_error     = /var/log/mysql/mysqld1-error.log
log-bin       = master-bin
log-bin-index = master-bin.index
server-id     = 1

[mysqld]
user            = root
port            = 3308
datadir         = /var/lib/mysql2
socket          = /tmp/mysql2.sock
pid-file        = /var/lib/mysql2/mysqld.pid
log_error       = /var/log/mysql/mysqld2-error.log
relay-log       = slave-relay-bin
relay-log-index = slave-relay-bin.index
server-id       = 2

Секции [mysqld1] и [mysqld2] отвечают за два разных сервера. Директивы, которые будут общими можно размещать в секции [mysqld]. Будем использовать разные сокет файлы, порты и пид файлы. Каталог данных указывается в datadir. Эти каталоги не существуют. В момент запуска серверов они будут созданы и проинициализированны. В том числе будет создана системная база данных MySQL. Это означат, что у каждого из серверов будет собственная таблица привилегий.

Чтобы не испытывать сложности с доступом к базе данных MySQL, лучше отключить проверку паролей и привилегий skip-grant-tables. Директива требует, чтобы настройки привилегий пользователей игнорировались и мы бы могли обратиться к серверам не указываю пароль.

sudo mysqld --defaults-file=/etc/mysql/my1.cnf &
sudo mysqld --defaults-file=/etc/mysql/my2.cnf &

sudo mysqld_safe --defaults-file=/etc/mysql/my1.cnf &
sudo mysqld_safe --defaults-file=/etc/mysql/my2.cnf &

mysql -u root -S /tmp/mysql1.sock
mysql -u root -S /tmp/mysql2.sock 

mysqladmin -S /tmp/mysql1.sock shutdown
mysqladmin -S /tmp/mysql2.sock shutdown

sudo mysqld --initialize-insecure --user=mysql --datadir=/var/lib/mysql2
sudo mysqld --initialize --user=mysql --datadir=/var/lib/mysql2  --log-error=tmp.log

mysqld_multi start -- стартует серверы
sudo mysqld_multi --defaults-file=/etc/mysql/my1.cnf start 1

sudo mysqld_safe --socket=/tmp/mysql1.sock --port=3307 --datadir=/var/lib/mysql1
sudo mysqld_safe --socket=/tmp/mysql2.sock --port=3308 --datadir=/var/lib/mysql2



drop user repl_user;
create user repl_user identified by '321321';
grant replication slave on *.* to repl_user; -- позволяет получать доступ к бинарному журналу

Задание журнала трансляций, т.е. тот журнал в который будут приниматься изменения из мастер сервера
relay-log       = slave-relay-bin
relay-log-index = slave-relay-bin.index
server-id       = 2


У слейв сервера также может быть свой бинарный журнал, если он собирается передавать данные дальше следующему слейв серверу

Заключительный этап, указать слейв серверу главный сервер, чтобы он знал откуда выполнять репликацию

Настройка репликации
- имя хоста
- порт
- учетная запись для репликации
- пароль к учетной записи

change master to master_host = 'localhost', master_port = 3307, master_user = 'repl_user', master_password = '321321';
change master to master_host = 'localhost', master_port = 3307, master_user = 'root';

start slave; -- запуск репликации
stop slave;

show slave status\G; -- просмотр статуса репликации

CHANGE MASTER TO GET_MASTER_PUBLIC_KEY=1;


Репликация не масштабирует запись!!!!! Масштабированию только подвергаются операции чтения. Если есть хоть какие-нибудь операции изменения INSERT, UPDATE, DELETE -- мы не можем масштабировать наш кластер бесконечно.

сервер операций insert   select
1      100 000  20 000   80 000 
2      200 000  40 000   60 000 
3      300 000  60 000   40 000 
4      400 000  80 000   20 000 
5      500 000  100 000  0

Таким образом с помощью репликации нельзя масштабировать систему бесконечно.

Шардирование, еще одна проблема при репликации. Все данные должны помещаться на одной машине. В случае, если данные не помещаются их нужно дробить и размещать копии на нескольких машинах. Такой подход называется СЕКЦИОНИРОВАНИЕ или ШАРДИРОВАНИЕ. Между этими частями также устанавливает отношение репликации, только здесь репликация выполняется не между серверами, а между фрагментами или секциями боьлшой базы данных. 

MySQL плохо поддерживает Шардирование из коробки.

Поддержка шардирования
- PostgreSQL
- MongoDB
- Cassandra
- ElasticSearch
- MySQL Cluster

Типы репликации
- синхронная - мастер-сервер ожидает ответа от всех реплик и счетает запрос завершенным тогда, когда данныхе сохранились на всех хостах, участвующих в репликации
- асинхронная - используется в классической БД MySQL. В этом случае все изменения применяются на мастер сервере, а на подчиненные сервера они поставляются с задержкой



Когда серверов появляется более чем один, появляеются различные варианты их использования.
Наиболее простая топология дублирования серверов - Горячий резерв, состоит из главного и выделенного сервера (горячий резерв, дублирует главный сервер). Сервер горячего резерва подключен к главному как подчиненный. В случае отказа главного сервера, сервер горячего резерва заменяет его. Это дает возможность переключить всех клиентов и подчененные сервера на резервный сервер и продолжить работу.

Топология MASTER - MASTER репликация. В ней используется два главных сервера, которые реплицируют изменения друг друга. Система проста в использовании. Каждый из местер серверов, сам может выступать в качестве главного сервера для целой группы MySQL серверов. Если на обоих серверах будут обновлена одна и та же информация, то между обновлениями может возникать конфликт, который может привести к останову репликации. Частично проблему можно решить, разрешив запись только на одном из серверов, т.е. один из серверов становится пассивным. Реть такие конфликты так же можно либо записывая информацию в разные таблицы, либо организовать запись таким образом, чтобы исключить конфликты. Большинство конфликтов связано со вставкой новых значений в таблицу, т.к. каждый из серверов ведут свой счетчик автоинкремент для первичного ключа.

Для решения этой проблемы MySQL предоставляет две серверные переменные 
-- auto_increment_offset -- назначает начальное значение всех столбцов 
-- auto_increment_increment -- устанавливает приращение значения в столбце AUTO_INCREMENT  


Первый сервер
set @@auto_increment_offset = 1;
set @@auto_increment_increment = 2;

insert ignore into catalogs values
    (null, 'Processors'),
    (null, 'Video cards'),
    (null, 'Radiators');


Второй сервер
set @@auto_increment_offset = 2;
set @@auto_increment_increment = 2;

insert ignore into catalogs values
    (null, 'Motherboards'),
    (null, 'Fans');

Идея МАСТЕР-МАСТРЕ репликации может быть распространена на множество серверов

Например, ТОПОЛОГИЯ КОЛЬЦО, но такая топология не рекомендуется, т.к. тяжело восстанавливается после сбоя.

--------------------------
-------- LESSON 8 --------
--------------------------

CREATE PROCEDURE procedure_name
CREATE FUNCTION function_name

DELIMITER $$
DROP PROCEDURE IF EXISTS shop.my_version$$
CREATE PROCEDURE shop.my_version()
BEGIN
    SELECT VERSION(); 
END

CALL my_version();

show procedure status; --- список хранимых процедур
show procedure status like 'my_version%'\G

select name, type from mysql.proc limit 10; -- список процедур

show create procedure my_version\G


DELIMITER $$
drop function if exists get_version$$
create function get_version() returns text 
begin
    return version();
end

deterministic -- означает, что функция возвращает одно и тоже значение, т.е. его можно закешировать
not deterministic -- нужен если например функция возвращает случайное значение

Типы параметров (только для процедур, для функций всегда IN)
-- IN
-- OUT
-- INOUT

Если не указать, то по умолчанию будет IN

Локальные переменные:
create procedure declare_var()
begin
    declare id, num int(11) default 0;
    declare name, hello, temp tinytext;
end;

Присвоение значения локальной переменной:
procedur p(seconds int)
begin
    declare days;
    set days = floor(seconds / 86400);
end

case var
    when '123' then
    when '456' then
    else 
end case;

Циклы:
-- WHILE
-- REPEAT
-- LOOP

while condition do
    .... some code
end while;


cycle: while condition do
    if condition_2 then leave cycle; -- досрочный выход из цикла
end while cycle;

cycle: while condition do
    if condition_2 then iterate cycle; -- досрочное завершени итерации
    end if;
end while cycle;

repeat 
    ... do something
until i < 0
end repeat;


loop

end loop


Обработчик исключения:
begin
    declare continue handler for sqlstate '23000' set @error = 'Ошибка вставки значения';
    insert into catalogs values (id, name);
    if @error is not null then
        select @error;
    end if;
end;


Курсор
declare curcat cursor for select * from catalogs; 
open curcat;
fetch curcat into id, name;
close curcat;

Триггеры:
create trigger catalogs_count after insert on catalogs
for each row
begin
    select count(*) into @total from catalogs;
end;

show triggers; -- отобразить триггеры

drop trigger catalogs_count; -- удаление

В триггерах есть спец переменные NEW, OLD, т.е. новая и старая записи

Предотвращение операции с помощью ТРИГГЕРА

Запретим удаление последней записи из таблицы
create trigger check_last_catalogs before delete on catalogs
for each row begin
    declare total int;
    select count(*) from catalogs;
    if total <= 1 then 
        signal sqlstate '4500' set message_text = 'delete canceled'; -- генерируем собственную ошибку
    end if;
end;

4500 -- пользовательские ошибки, их нельзя перехватить с помощью обработчиков



--------------------------
-------- LESSON 9 --------
--------------------------

Виды таблиц:

Задание таблиц можно выполнить при ее создании в create table. Для этого указывается ключевое слово ENGINE

create table catalogs (
    id serial primary key,
    name varchar(255) comment 'название раздела'
) comment = 'Разделы интернет-магазина' ENGINE=InnoDB;


Ядро:
- осуществляет поддержку соединения с клиентами
- применение правил и логики языка SQL
- кэширование запросов

Подсистема хранения (движки):
- за хранение данных
- выполнение нискоуровневых операций с хранилищем 

Примеры движков InnoDB, MyISAM, Memory, Archive

По умолчанию используется движок InnoDB

Memory -- размещает данные в оперативной памяти
Archive -- сжимает данные

Архитектура ядра MySQL
-- пул соединения с клиентами, обеспечивает каждого из них сессией и обрабатвает его запросы
-- если включен Кэш запросов, то каждый запрос сначала проверяется в кэше
-- если запрос не найден в Кэше то он идет в Анализатор, который разбивает запрос на лексемы и строит дерево разбора. Анализатор использут грамматику языка SQL
-- дерево разбора передается Препроцессору, который контролирует дополнительную семантику не входящую в компенетцию Анализатора. Например, проверяется, что указанные таблицы и стоблцы существуют. Далее Препроцессор проверяет привелегии пользователя.
-- далее Оптимизатор превращает дерево в План выполнения запроса. Существует множестов одинаковых запросов. Задача Оптимизатора выбрать лучшиый из них. Оптимизатор имеет свободу действий по выбору пути исполнения запроса и выборц индексов, которые будут применяться. Он привлекает статистику сервера для выбора наиболее оптимального пути.

-- После того, как план выполенния запроса выбран, происходит его выполение с использованием API подсистемы хранения, т.е. ядро обращается к низкоуровневому вызову движка таблицы

Файлы таблиц
Под каталоги для каждой из таблиц создаются файлы с расширением FRM и именем совпадающим с именем таблицы. В этом файле хранится определение таблицы: список столбцов, их типы и порядок следования. Он одинаков для каждого движка. 

А вот данные и индексы для каждой системы хранения реализуются по-разному. За их работу отвечают движки таблиц.
Например, для типа таблиц MyISAM данные сохраняются в одноименном файле с расширением MYD, а индексы в файле MYI. В InnoDB все данные и индексы всех таблиц храняться в одном табличном пространстве в файле ibdata1. Хотя если в my.cnf включить директиву innodb_file_per_table, можно перевести InnoDB в режим, когда для каждой таблицы будет организовано свое собственное пространство в файле с расширением IBD

ibtmp1 -- содержит временные таблицы
ib_logfile0, ib_logfile1 -- файлы журнала транзакций

shop/
*.frm, *.ibd -- структура и данные
*.trn -- предназначены для работы триггера

show table status -- показывает какой используется движок для таблицы

show table status like 'catalogs'\G

show engines\G -- список доступных движков и их характеристики


InnoDB -- был разработан для транзакционной обработки и автоматического восстановления после сбоя. Поддерживает внешние ключи и блокировку на уровне строк. Система хранения данных не кеширует инфу о количесве строк в таблице, в отчетах эта цифра чаще всего приблизительная, а выполнение запросов с функцией count(*) очень трудоемкие, так как каждый раз выполняется полное сканирование таблицы

Memory -- полностью рассположены в памяти и не поддерживают транзакции. При перезапуске сервера содержимое таблиц обнуляется. Операции с таким типом таблиц происходят исключительно быстро. При операциях вставки производится табличная блокировка, т.е. нельзя одновременно вставлять две записи в таблицу, такие операции выстраиваются в очередь. По умолчанию используются Hash индексы. В настоящее время они редко используются, т.к. существуют более эффективные NoSQL решения для таких задач, например Reddis

BLACKHOLE -- используется в качестве ретранслятора бинарного журнала когда с этим не справляется реплика. Например в топологии пирамида, когда к нагруженному мастер-серверу подключить множество slave серверов в этом случае сервер, который реально не выполняет запросов справляется с передачей бинарного журнала гораздо лучше. Для организакции такого сервера таблицам назначается тип BLACKHOLE

MyISAM -- файловый движок, нет транзакий, производится блокировка при вставки.

MRG_MyISAM -- объедиенние нескольких таблиц MyISAM в одну виртуальную таблицу, до некоторой степени это материализованный union запрос

CSV -- позволяет просматривать текстовые файлы *.csv с разделителем ',' как таблицы.

ARCHIVE -- позволяет выполнять только INSERT и SELECT. Таблицы этого типа потребляют исключительно мало памяти. Снижаю дисковый ВВОД/ВЫВОД так как данные сжимаются библиотекой zlib. Чаще всего используется для протоколирования и сбора данных. Поддерживает блокировку на уровне строк. И спец системный буфер для вставки с высокой степенью конкурентности. Не поддерживает транзакции. Оптимизирована для высокоскоростной встаки и хренения данных в сжатом виде.


ОПТИМИЗАЦИЯ ЗАПРОСОВ, Подробнее об индексах
-- Кэширование индексов
-- Управление выделением памяти
-- Различие в оптимизации MySQL под разные типы таблиц
-- Эффективность индексов

Индексы стараются хранить в оперативной памяти вместо хранения на жестком диске. Есть огромное количество разнообразных Кэшей.
Часть кэшей выделяется на ядро и является общим для всех соеднинений. Часть кэшей выделяется на каждое соединение.
Например, кэши для индексов являются общими для всех клиетов, а кэши под сортировку данных индивидуальные для каждого соединения.


[mysqld]                                Ядро
.....                                   
query_cache_size = 0                    0 +
key_buffer_zie = 8M                     8M +
innodb_buffer_pool_size = 1024M         1024M +
innodb_additional_mem_pool_size = 8M    8M +
innodb_log_buffer_size = 8M             8M +
...                                   = 1056M
max_connections = 200
...
read_buffer_size = 1M                   1M +
read_rnd_buffer_size = 1M               1M +
sort_buffer_size = 2M                   2M +
thread_stack = 256K                     256K +
join_buffer_size = 128K                 128K +
                                      = 3.5M
                                      3.5 * 200 = 700M

В этой конфигурации ядро может занять четь больше 1Gb, а каждое из соединений порядка 3.5M, максимальное количество соединений = 200. Таким образом при максимальной нагрузке на соединения удей порядка 700Mb оперативной памяти. В реальности кончено меньше, т.к. не все соединения будут использовать кэши. Кэши ядра тоже редко бывают заполены под завязку. Если на сервере имеется большое количество памяти, то можно увеличить пул буферов innodb для кэширования индексов и данных

innodb_buffer_pool_size = 8G
max_connections = 500             500*3.5 = 1750M


В результат при максимальной нагрузке сервер будет потреблять чуть меньше 10Gb.

За реализацию индексов отвечатся подсистемы хранения. По этому в разных системах хранения кэширование индексов может осуществляться по разному. Например, MyISAM данные и индексы разделены по разным файлам. Данные всегда ноходяться на жесток диске, индексы помере необходимости подтягиваются в оперативную память в кэш индексов. При необходимости данные кэшируются средствами операционной системы. Поэтому если MyISAM это основной тим таблиц, важно на сервере оставлять какое-то количество свободной памяти.
В InnoDB индексы и данные храняться в одном табличном пространстве, поэтому когда говорится о кэшировании InnoDB имеется ввиду, что в оперативной памяти размещаются и индексы и данные. Связано этом с тем, что в innodb для первичного ключа используется кластерный индекс. Это почти тоже самое, что и бинарное дерево в индексах, только в качестве листьев выступают строки таблицы. Над таблице можно построить только один кластернй индекс, поскольку невозможно хранить одну и ту же запись в разных местах.

Оценка оперативной памяти, выделенное под MyISMA индексы.
show variables like 'Key%';
key_buffer_size   -- объем в байтах выделенный под этот кэш, максимальный размер 4Gb

Оценка эффективности данного кэша:
show status like 'Key%';
key_blocks_used -- количество занятых блоков в кэше
key_blocks_unused -- количество свободных блоков в кэше
key_read_request -- количество блоков прочитанных из кэша
key_reads -- количество блоков прочитанных с жесткого диска в кэш
key_write_requests -- анлогичен, только запись
key_writes -- анлогичен, только запись

Оценка пула буфера innodbf
show variables like 'innodb_buffer_pool_size'; -- по умолчанию 128M, под индексы и под данные innodb
Под пул буффер рекомедуется выделять 50-80% оперативной памяти, т.е. 2, 4, 8, 16 GB если это позволяют ресурсы сервера.
Т.к. кэшируются не только индексы но и данные пул буферов должен быть объемным. Если ресурсы позволяют, желательно, чтобы база данных целеком проваливалась в пул буфер, а к жесткому диску БД обращалась только для записи транзакций. Однако бесконечно увеличивать кэши нельзя. Если оперативная память будет исчерпана, часть данных будет сбрасываться на жесткий диск в своп. При обращении к этим данным ОС будет вынуждена выгрузить другие данные из оперативной памяти и подгрузить запрашиваемые. В результате скорость БД и ОС может упасть критически. Лучше наращивать значения параметров постепенно чательно отслеживая состояние ОС.

Оценка эффективности кэша innodb:
show status like 'Innodb_buffer_pool_%';
Innodb_buffer_pool_pages_total -- Общее количество блоков в кэше
Innodb_buffer_pool_pages_free -- количество свободных блоков, если величина исчерпана, то имее увеличить количество памяти под innodb
Innodb_buffer_pool_pages_data -- количество занятых блоков
отношение операций чтений и записей показывает эффективность кэша
Innodb_buffer_pool_reads -- количество чтений с жесткого диска
Innodb_buffer_pool_read_requests -- количество чтений с из оперативной памяти 



ОПТИМИЗАЦИЯ ЗАПРОСОВ
-- приемы оптимизации
-- команда explain
-- исследование плана выполнения запроса
-- использование индексв в запросе


Способы оптимизации
-- меньше возвращать запросом данных -- касается количества возвращаемых запросом строк и данных в столбцах. Если необходимо 2, 3 стоблца, то не следует извлекать данные из всех столбцов при помощи зведочки. Нужно огарничивать количество строк.
-- меньше null-значений -- стоблцы varchar и null хранятся в специальной области для данных переменной длины. Эти данные обрабатываются менее эффективно, чем данные фиксированной длины. Например, целый тип INT. Поэтому, если вам не нужно значение null столбца, лучше явно указвать атрибут NOT NULL
-- меньше типов TEXT и BLOB -- еще медленнее чем все остальные типы данных, т.к. хранятся отдельно от стаблцов таблицы. Большенство операций с их участием часто протекают с участием жесткого диска. Лучше исключать данные стоблцы из запроса.
-- небольшие промежуточные таблицы
-- по возможности избегать полного сканирования таблиц

Основной способ унать какие решения принимает оптимизатор это воспользоваться командой EXPLAIN
EXPLAIN select id, name from catalogs order by id\G
Для каждой таблицы выводится одна строка. Если одна и таже таблица попадается дважды, тоже будет выведено две строки.
Может применяться только SELECT-ам

select_type -- простой или составной запрос
table -- таблица к которой отнистся строка
type -- метод доступа к таблице, как mysql будет искать строки в таблице, ALL - полное сканирование таблицы
Отсортированы от самых худших к лучшим
-- ALL     - просмотр таблицы от начала до конца, чтобы найти нужную строку. Есть исключения для LIMIT. Будет прекарщен выбор как только будет набрано необходимое количество записей
-- index   - полное сканирование таблице в порядке, который задается индексом
-- range   - просмотр диапазона индекса, тоже производится сканирование, но сканиврование индекса. Часто можно встретить в случае between условий или операций < и >.
-- ref     - деступ по индексу. В результате возвращаются строки, которые соотвествуют единственному заданному значению. Таких строк может быть несколько. Поэтому индекс сочетается с просмотром. Возможен лишь в случае неуникального индекса.
-- eq_ref  - метод поиска по индексу, когда mysql знает, что будет возвращено не более одного значения
-- const   - кауюто часть запроса можно преобразовать в константу
-- NULL    - СУБД сумела разрешить запрос на фазе оптимизации, т.е. не потребуется обращаться к таблице или индексу

Методы ALL и index обращаются к данным таблицы, метод range работает с индексом. Когда используется RANGE - это значит, что данных в индексе достаточно для исполнения операции, однако потребуется перебор индекса в достаточно большом интервале.
Иногда совместно с типом index в дополнительном поле extra можно увидеть сообщение using index. В этом случа речь идет об покрывающем индексе. Здесь тоже происходит сканирование индекса, но значений индекса достаточно, чтобы дать ответ,т.е. нет нобходимости обращаться к жесткому диску.

possible_keys -- какие индексы можно было бы задействовать для исполнения запроса. В простом запрос может быть задействован только один индекс

key -- выбранный оптимизатором индекс
key_len - показывает сколько байт индекса используется mysql. Например, может использоваться лишь часть составного индекса. Позволяет соориентироваться какая часть индекса используется.
ref -- показывает какие столбцы и константы используются для поиска в индексах
rows -- сколько строк придется прочитать, чтобы найти запрошенные данные, чем меньше, тем быстрее будет выполняться запрос
filtered -- сколько строк удовлетворяет критерию выборки. Чем меньше этот процент, тем меньше данных придется отбрасывать mysql при сканировании таблицы
extra -- доп инфа для которой не нашлось места в других столбцах
-- Using index - будет использоваться покрывающий индекс
-- using where - сервер производит дополнительную фильтрацию строк отобранных под систему хранения
-- using temporary - будет применена временная таблица для сортировки результата запроса. Если ее объем позволяет, она будет размещена в оперативной памяти. Максимальный размер временной таблицы задается директивой tmp_table_size
-- using filesort - будет производиться обычная сортировка для упорядочивания результата. mysql не будет читать таблицу в порядке который задается индексом


--------------------------
-------- LESSON 10 --------
--------------------------

NoSQL-базы данных
- Причины зарождения NoSQL
- Современные приложения
- Классификация NoSQL-баз данных
- CAP-теорема

Проблемы и вызовы
- распределенные БД
- шардирование
- новые форматы хранения
- большие данные
- масштабирование записи

Современное приложение
- MySQL - основная база данных. Из-за поддержки транзакций очень медленная для обработки данных, сбор статистики, блокировка большого диапазона строк в таблице
- Redis - кэш в оперативной памяти. Данные, которые не часто меняются.
- ElasticSearch - полнотекстовый поиск. Может не поддерживать транзакции.
- ClickHouse - колоночная БД. Для хранения и общета статистики. Не позволяют обновлять и удалять данные, но позволяют в режиме реального времени получить агригационные данных

NoSQL базы данных (NoSQL термин появился в 2009, и обозначает нереляционные БД)
- ключ-значение. Вместо таблиц используется ключ с которым ассоциируется один или несколько атрибутов. React, DynamoDB, MemCached и Redis
- столбцовые / колоночные. В одном месте хранятся данные одного стоблца. (В реляционных - данные одной строки). Кадый столбец зачастую хранится в отдельном файле, что позволяет более эффективного сжимать дынне и сортировать стоблцы. Cassandra, HBase, ClickHouse
- документоориентированные. Единица хранения - целый документ часто в формате json, xml, yaml. В документ можно добавлять произволные ключи и значения. Часто такие БД называют без схемными или не структурированными. CouchDb, MongoDB
- графовые. Представлена множеством вершин и соединяющих их множества ребер. Основной упор делается на связях. Часто применяются для построения соцсетей. FloatDB, Neo4j, Polyglot.
- объектные. Данные хранятся ввиде объектов. Что упрощает работу с БД из объектно ориентированного приложения. В результате можно обходиться без хранимых процеду и без ORM. Db4o, InterSystems Cache.
- полнотекстового поиска. Основная структурная единица - документ. Часто используется не структурированная система хранения. Основное упор делается на поисковый механизм. Solr, Elasticsearch.

Реляционные БД создавались во времена, кода данные умещались на одном сервере и максимум в одном датацентре. В текущей ситуации имеем дело с несколькими серверами и зачастую с несколькими датацентрами.

NoSQL - решают самые разные задачи. Одной из главных задач является поиск компромиса между согласованностью, доспуностью и способностью к разделению - CAP-теорема (consistency, availobility, parition tolerance).

Согласованность (Consistency) -- любая операция чтения возвращает самое последнее записанное значение. Например, когда настраиваем реплицию и слейв сервер отстает от мастер сервера мы не обеспечиваем согласованность данных. Прочита данные со слейв сервера можем получить не самый последний результат.

Доступность (Availability) -- клиенты имеют возможность всегда читать и записывать данные.

Способность к разделению (Partition tolerance) -- БД можно распределить по нескольким машинам или датацентрам и БД продолжет работу даже после отказа сегмента сети.

CAP-теорема утверждает, что в любой системе можно гарантировано обеспечить выполнение только двух из этих трех требований.

У кадой БД есть своя специализация.
CA -- в случае разделения сети система блокируется, т.е. такие БД должны работать в одном датацентре. MySQL, PostgreSQL
CP -- вводится сегментирование или шардирование данных. В случае отказа, часть ддых может быть недоступна. Redis, MongoDB
AP -- могут возращаться неточные данные, но зато БД будет всегда доступна даже в случае разделения сети. Cassandra, Riak



Key-Value хранилища Redis
- преимущества Redis
- клиент redis-cli
- как пользоваться документацией
- типы данных Redis
- время жизни ключа
- базы данных Redis

 Используется в качестве Кэша, Очереди и обмена Pubsub сообщений. Процессору не преходиться переключаться 

 Преимущества Redis
 - высокая производительность до 100_000 RPS  - 
 - расположение данных                        - в оперативной памяти. Допускается сохранение данных на жесткий диск.
 - время жизни ключей.                        - Ключам допускается назначение времени жизни. Тем самы можно очищать старые данные в фоновом режиме.
 - поддержка транзакций                       - 
 - репликация и sentinel-кластеризация        - в случае выхода из строя мастер сервера, оставшиеся ноды проголосуют и выберут новый мастер сервер.
 - механизм подписка                          - можно строить очереди заданий. Допустим при загрузки изображения из него нужно нарезать десятки различных вариантов. Операции может занять длительное время и лучше ее выполнить в фоновом режиме не задерживая пользователя. В этом случае задание можно поместить в очередь и завершить обслуживание запроса.
 - поддержка языков на языке Lua              - что позволяет связать его напрямую с сервером Nginx


REDIS

redis-cli, default port=6379, выход из клиента quit, exit
redis-benchmark -n 100000 -- осуществляет проверку производительность на текущем сервере.
соединение обрабатывает один поток в неблокирующем режиме
HELP PING
HELP @connection -- получение справки по группе команд
HELP @ -- нажатие TAB для перебора доступных групп
SET key 'Hello world!'
GET key
MSET fst 1 snd 2 thd 3 fth 4 -- одновременная вставка нескольких значений
MGET fst snd thd fth -- получение нескольких значений
APPEND key ' world' -- добавляет в конец строки значение
INCR count -- увеличить значение на 1
INCRBY count +/-5 -- на произвольное целое значение
DECR/DECRBY
INCRBYFLOAT count 1.3 -- Добавлять / отнемать вещественные числа
DEL key -- удаление пары ключ-значение
KEYS * -- получение списка ключей в БД
KEYS f* -- более сложный шаблон поиска ключей
RENAME key hello_world -- переименование ключа
SET timer "one minute" -- установка актальности кэша
EXPIRE timer 60 -- для задания срока хранения ключей, время в секундах
EXISTS timer -- 1 - если время не истекло, 0 - если истекло
TTL timer -- сколько осталось до истечения срока жизни ключа

























