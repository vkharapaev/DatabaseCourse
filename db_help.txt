3306
33060
admin
service MySQL80

root

--------------------------
-------- LESSON 1 --------
--------------------------

mysql -u root -h 192.168.0.10 -P 3306 

USE    \u выбор базы данных
SOURCE \. Выполнение sql-команды из файла
SYSTEM \! Выполнение команды операционной системы
STATUS \s Вывод информации о состоянии сервера
EXIT   \q выход
       \G вывод результата в вертикальном формате

SOURCE hello.sql -- выполнение файла hello.sql

Файл с учеткой для автоматического подключения
-----
my.cnf
[client]
user=admin
passord=admin

mysqldump mysql > mysql.sql -- экспорт базы данных mysql в файл mysql.sql
mysql mysql < mysql.sql -- импорт данных из mysql.sql в базу данных mysql

CREATE DATABASE shop CHARACTER SET utf8 COLLATE utf8_general_ci;
drop database shop;

create database shop;
show databases;
show variables like 'datadir';
drop database shop;
create database if not exists shop;
use shop
show tables;
show tables from mysql; -- указали базу данных mysql
select mysql.User.User, mysql.User.Host from mysql.User; -- запрос с квалифицированными именами
mysql shop; -- подключение с одновременным указанием базы данных

create table users (k int);
create table if not exists users (k int);
describe users; -- просмотр структуры таблицы
describe user 'User'; -- оператору можно указать имя столбца
describe user 'm%'; -- можно указывать шаблоны для сталбцов '_', '%'

SELECT * FROM information_schema.SCHEMATA;

select * from information_schema.TABLES where table_schema = 'shop';


--------------------
---------ДЗ LESSON 1
--------------------

Задание 2
create database example;
create table users(id int, name text);
mysqldump example > example.sql
create database sample
mysql sample < exmaple.sql

Задание 3
mysqldump --where="1 limit 100" mysql help_keyword > help_keyword.sql


----Разбор домашки
-------------------

create table if not exists users (
    id SERIAL COMMENT 'Table primary key', -- BigInt, первичный ключ, автоинкремент
    name VARCHAR(255) COMMENT 'User name'
);


SHOW CREATE TABLE users

SOURCE example.sql

mysqldump --skip-opt --where="1 limit 100" mysql help_keyword > help_keyword.sql    // --skip-opt - сделает несколько insert-ов вместо одного




--------------------------
-------- LESSON 2 --------
--------------------------

Типы данных
TINYINT   1 byte
SMALLINT  2 byte
MEDIUMINT 3 byte
INT       4 byte
BIGINT    8 byte

Вещественные
FLOAT  4 byte 
DOUBLE 8 byte
DECIMAL -- более точный тип. обрабатывается дольше всех типов. Число хранится в виде строки. Тип без потери точности

CREATE TABLE tbl(id INT(8)) -- 8 - указывает сколько символов печатать в консоле. необязательный параметр
'       5' -- пример печати в консоле

CREATE TABLE tbl(id INT(8) ZEROFILL)
'00000005' -- пример печати в консоле

DECIMAL(7,4) -- под число отводится 7 байт, а под дробную часть 4 байта

CREATE TABLE tbl (price DECIMAL(7,4));


Строковые типы:
CHAR - фиксированная длина

VARCHAR - переменная длина строки, в скобках указвается максимальная длина строки. Максимальная длина 65536

BLOB
TINYTEXT   2 ^  8 = 256
TEXT       2 ^ 16 = 65536 
MEDIUMTEXT 2 ^ 24 = 16777216(16Mb)
LONGTEXT   2 ^ 32 = 4294967296(4Gb)

create table tbl (
    name char(10) default 'anonymous',
    description varchar(255)
);
insert into tbl values (default, 'New user');
insert into tbl values ('Игорь', 'New user');

ALT+X - выполнить скрипт в dbeaver



Тип NULL
    Все операции с данным типом приводят к типу NULL


create table tbl (id int unsigned);
alter table tbl change id id int unsigned not null;
truncate tbl;


Каледнарные типы даннх:                                                               
YEAR - хранит год                                                                   1 byte 0000
DATE - хранит дату с точностю до дня                                                3 byte 0000-00-00
TIME - для хранения времени в течение суток                                         3 byte 00:00:00
TIMESTAMP - также хранит дату и время. занимает в 2 раза меньше                     4 byte 0000-00-00 00:00:00
   места чем DATETIME, но может хранить даты в ограниченном интевале от 1970-2038гг   
DATETIME - хранит дату и время                                                      8 byte 0000-00-00 00:00:00


select '2018-10-01 0:00:00' - interval 1 day; -- вычли из даты 1 день
select '2018-10-01 0:00:00' + interval 1 week; -- прибавили 1 неделю к дате 
select '2018-10-01 0:00:00' + interval 1 year; -- прибавили 1 год к дате 

комбинированные интервалы
select '2018-10-01 0:00:00' + interval '1-1' year_month; -- прибавили 1 год и 1 месяц к дате 

Enum и Set типы данных
При создании столбца данного тип значения задаются строковым списком через запятую 'first', 'second', 'third', но значения в столбце хранятся в виде чисел.

alter table tbl add collect json;
insert into tbl values (1, '{"first":"Hello", "second":"World"}'); -- вставка json Объекта
select collect->>"$.first" from tbl; -- получение значения поля json Объекта



Типы индексов:
Обычные - может быть несколько
уникальные, первичные - может быть в таблице только один. в строках данного столбца могут храниться только уникальные данные. значения не могут принимать NULL
полнотекстовые - предназначен для столбцов типа text, позволяющий проводить полнотекстовый поиск. На практике же полнотекстовый поиск осуществляется субд ElasticSearch


Включение механизма auto_increment
insert into catalogs (name) values ('Processors');
insert into catalogs values (NULL, 'Motherboards');
insert into catalogs values (0, 'Video cards');
insert into catalogs values (default, 'Video cards');


Псевдотип SERIAL
SERIAL == BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE

Mysql поддерживает 2 тип индексов BTREE и хэштаблицу


CRUD ОПЕРАЦИИ
--------------
DELETE FROM catalogs;
TRUNCATE catalogs; -- очищает таблицу и обнуляет счетчики auto_increment



--------------------------
-------- LESSON 3 --------
--------------------------

'5' + '2' = 7
5 div 2 = 2 -- целочисленное деление
5 % 2 = 1 -- остаток от деления
5 mod 2 = 1 -- остаток от деления
true и false -- костанты. тип tinyint 1 и 0 соотвественно
<=> -- безопасное сравнение, позволяет сравнивать со значением NULL, nlow
not, ! -- отрицание
2 = NULL -- NULL
2 != NULL -- NULL
2 <=> NULL -- 0
NULL <=> NULL -- 1

create table tbl (
    x int,
    y int,
    summ int as (x + y) -- вычислется при обращении, не сохраняется на диске
);


create table tbl (
    x int,
    y int,
    summ int as (x + y) stored  -- сохраеяется на диске, более того, мы можем его индексировать
);

between 1 and 100
not between 10 and 70

select 2 in (0, null, 5, 'str') -- null
not in 

\% -- чтобы вывести %
\_ -- чтобы вывести _



RLIKE или REGEXP -- регулярные выражения

LIMIT 3, 4 -- 3 - позиция, начиная с которой необходимо вернуть результат, 4 - количество извлекаемых записей
LIMIT 4 OFFSET 3 -- тоже самоей

select distinct catalog_id from products order by catalog_id


----
---- МЕТОДЫ
----

NOW() -- текущее время и дата. за время запроса вычиляется только один раз, не зависимо от количества вызовов этого метода

DATE(date) -- отрезает время
DATE_FORMAT('2018-06-12 01:59:59', 'На дворе %Y год') -- на дворе 2018 год
DATE_FORMAT(birthday_at, '%d.%m.%Y') as birthday_at

UNIXSTAMP -- данный формат даты числовой, обрабатывается быстро, можно идексировать и занимает меньше места 4 байта, DATETIME - 8байт. Хранит даты от 1970 по 2038 год

UNIX_TIMESTAMP() -- преобразование в UNIXSTAMP
FROM_UNIXTIME() -- преобразование из UNIXSTAMP

SELECT UNIX_TIMESTAMP('2018-10-1O 10:09:23') AS TIMESTAMP, FROM_UNIXTIME(1539155363) AS DATETIME; -- 1539155363, 2018-10-1O 10:09:23

TO_DAYS() -- получение количесва дней 
FLOOR() -- избавление от дробной части

TIMESTAMPDIFF(YEAR, birthday_at, now()) -- более точный вариант

select * from users order by RAND() -- вывод строк в случайном порядке

VERSION() -- текущая версия MySQL сервера

LAST_INSERT_ID() -- последний id вычисленный автоинкриментом

DATABASE() -- возвращает текущую выбранную базу данных

USER() -- текущий пользователь


---------МАТЕМАТИЧЕСКИЕ ФУНКЦИИ

SQRT() -- квадратный корень числа


create table distances (
    id SERIAL PRIMARY KEY,
    x1 INT NOT NULL,
    x2 INT NOT NULL,
    y1 INT NOT NULL,
    y2 INT NOT NULL,
    distance DOUBLE AS (SQRT(POW(x1 - x2, 2) + POW(y1 -y2, 2)))
) COMMENT = 'Расстояние между двумя точками';

create table distances (
    id SERIAL PRIMARY KEY,
    a JSON NOT NULL,
    b JSON NOT NULL,
    distance DOUBLE AS (SQRT(POW(a->>'$.x' - b->>'$.x', 2)+POW(a->>'$.y' - b->>'$.y', 2)))
) COMMENT = 'Расстояние между двумя точками';


square DOUBLE AS (a * b * SIN(RADIANS(angle))/2.0)

alter table triangles change square square DOUBLE AS (ROUND(a * b * SIN(RADIANS(angle))/2.0))

ROUND() -- математическое округление
CEILING() -- округление в большую сторону 

------ СТРОКОВЫЕ ФУНКЦИИ
SUBSTRING(name, 1, 5) -- получение подстроки, 1 - позиция начала, 5 - количество извлекаемых символов
CONCAT() -- объединение строк

IF(TRUE, 'истина', 'ложь') -- функция условия

select 
    case 
        when color = 'red' then 'красный'
        when color = 'orange' then 'оранжевый'
        else 'фиолетовый'
    end


INET_ATON('62.145.69.10') -- представление IP адреса ввиде целого числа
INET_NTOA() -- решает обратную задачу

UUID() -- возвращает универсальный уникальный идетификатор


--------------------------
-------- LESSON 4 --------
--------------------------

GROUP_CONCAT(column name) -- показывает какие значения попали в группу. Может извлечь максимум 1000 элементов, но можно изменить с помощью параметра сервера GROUP_CONCAT_MAX_LEN 
GROUP_CONCAT(name SEPARATOR ' ') -- позволяет указать заделитель
GROUP_CONCAT(name ORDER BY name DESC SEPARATOR ' ') -- позволяет добавить сортировку значений

COUNT(column) -- исключаются NULL значения
COUNT(DISTINCT catalog_id) -- исключаются повторяющиеся значения

SELECT * FROM users HAVING birthday_at >= '1990-01-01'; -- можно использовать HAVING без GROUP BY. В этом случае каждая строка рассматривается как отдельная группа

ANY_VALUE() -- возвращает случайное значение группового поля

WITH ROLLUP -- для подведения итогов по сгруппированным данным.

CONCAT_WS('-', 2019,  10, 31); -- 2019-10-31


--------------------------
-------- LESSON 5 --------
--------------------------
Типы многотабличных запросов
- объединения (union)
- вложенные запросы 
- соединение (join)

1) Опрерации над множествами
- union (поддержано MYSQL)
- except - разность
- intersect - пересечение

2) Вложенные запросы
select id, <SUBQUERY> from <SUBQUERY> where <SUBQUERY> group by id having <SUBQUERY>

3) Тип JOIN соединений
- join (inner join)
- left join - справа допускаются NULL
- right join - слева допускаются NULL
- outer join (неподдержано MYSQL)


UNION (ALL OR distinct)
ORDER BY действует на весь результат запроса с оператором UNION, а не на отдельные таблицы
Для LIMIT выполняется тоже самое
Это можно обойти с помощью вложенных запросов, например
(select name from catalogs order by name desc limit 2) union all (select name from rubrics order by name desc limit 2)
Первый SELECT запрос определяет название стобцов
UNION запросы выполняются долго. Почти всегда промежуточная таблица размещается на жестком диске, следовательно сортировка и фильтрация также будет выполняться во временном файле. Следует указвать только необходимые стоблы в запросе. Чем меньше столбцов, тем меньше размер промежуточной таблицы и тем быстрее проходят операции с ней.


Кореллированный запрос - если вложенный запрос использует столбец из внешнего запроса. Субд вынуждена вычислять подзапрос для каждой строки запроса, что может быть накладно для объемных таблиц.

Если подзапрос возвращает более одного результата, то будет ошибка. В таких случаях можно использовать например оператор IN (это оператор равенства в отношении множеств)

select * from products where catalog_id = 2 and price < ANY (select price from products where catalog_id = 1)


condition operator ANY или SOME - выражение считается истиным, если хотя бы одно из значений true
condition operator ALL - выражение считается истиным, если все значения true

[not] exists - используется для проверки, есть ли во вложенном запросе записи. возвращает TRUE/FALSE


MYSQL реализованы строчные запросы, т.е. подзапросы, которые возвращают более одного стоблца

select id, name, price, catalog_id from products where (catalog_id, 5060.00) in (select id, price from catalogs); -- где (catalog_id, 5060.00) - коструктор строки, его можно записывать с помощью ключевого слова RAW(catalog_id, 5060.00)

Декартово произведение
select * from tbl1, tbl2
select * from tbl1 join tbl2


select p.name, p.price, c.name from catalogs as c join products as p where c.id = p.catalog_id
select p.name, p.price, c.name from catalogs as c join products as p on c.id = p.catalog_id

Условивие в ON отрабатывает в момент соединения таблиц, т.е. промежуточная таблица сразу получается небольшой, в то время как WHERE условие действует после соединения, сначала получам декартово произведение затем выполняется фильтрация

Запросы с самообъединением таблиц - запрос в которых одна и таже таблица подключается 2 и более раз.

Когда название стоблцов таблиц по которым выполняется объединение равны, то можно вместо ON использовать USING(название стобца)
select * from catalogs as fst join catalogs as snd USING(id);


Многотабличный запрос можно использовать для обновления или удаления данных
select catalogs join products on catalogs.id = products.catalog_id set price = price * 0.9 where catalogs.name = 'Мат.платы';
delete products, catalogs from catalogs join products on catalogs.id = products.catalog_id where catalogs.name = 'Мат.платы'; -- удалятся записи из обоих таблиц
delete products from catalogs join products on catalogs.id = products.catalog_id where catalogs.name = 'Мат.платы'; -- удалятся записи только из products 

ОГРАНИЧЕНИЕ ВНЕШНЕГО КЛЮЧА

foreign key (col1, ...) references tbl (tbl_col, ...) [on delete ...] [on update ...]

cascade - удалит или обновить при изменении родителя
set null - установить в Null при удалении или обновлении родителя
no action - оставить как есть при удалении или обновлении родителя
restrict - запретить удаление, если в дочерней таблице есть записи ссылающиейся на родителя
set default - установиь DEFAULT значение при удалении или обновлении родителя

alter table products add foreign key (catalog_id) references catalogs(id) on delete no action on update no action; -- имя задастся автоматически
alter table products add constraint fk_catalog_id foreign key (catalog_id) references catalogs(id) on delete no action on update no action;
alter table products drop foreign key products_ibfk_1;

--------------------------
-------- LESSON 6 --------
--------------------------

START TRANSACTION;
ROLLBACK;   

Нельзя выполнить откат следующих команд
CREATE INDEX, DROP INDEX, CREATE TABLE, DROP TABLE, TRUNCATE TABLE, ALTER TABLE, RENAME TABLE, CREATE DATABASE, DROP DATABASE, ALTER DATABASE

Команды, которые неявно завершают транзакцию
ALTER TABLE, BEGIN, CREATE INDEX, CREATE TABLE, CREATE DATABASE, DROP DATABASE, DROP INDEX, DROP TABLE, DROP DATABASE, LOAD MASTER DATA, LOCK TABLES, RENAME, SET AUTOCOMMIT=1, START TRANSACTION, TRUNCATE TABLE

Транзакции не могу быть вложенными

SAVEPOINT
ROLLBACK TO SAVEPOINT

SET AUTOCOMMIT = 0/1 -- enable / disable autocommit.

Transactions should be ACID
- Atomicy - атомарность - все части транзакции либо одновременно выполняется, либо отменяются, т.е. нет частично выполненных транзакций
- Consistency - согласованность, БД переходит из одного непротиворечивого состояние в другое непротиворечивое состояние
- Isolation - изолированность - результат текущей транзакции не виден другим транзакция пока текущая транзакция не закончена
- Durability - сохраняемость - изменения в ходе транзакции будучи зафиксированы становятся постоянными

Уровни изоляции транзакций:
- READ UNCOMMITTED -- транзакции могут видеть результаты не зафиксированных транзакций  
- READ COMMITTED -- транзакции увидят только те изменения, которые уже были зафиксированны другими транзакциями к моменту ее начала, а произведенные ею изменения останутся не видимыми для других транзакций, пока текущая транзакция не будет зафиксированна. На этом уровне возможен феномен Невоспроизводимого чтения. Т.е можете выполнить одну и ту же команду и получить различные результаты
- REPEATABLE READ -- по умолчанию, решает проблемы предыдущих уровней Возможен Фантомного чтения
- SERIALIZABLE


SET TRANSACTION ISOLATION LEVEL READ COMMITED;

show variables like 'datadir'; -- путь к системного каталогу
ib_logfile0, ib_logfile1 -- файлы журнала транзакций

INODB - хранит все таблицы всех баз данных в едином табличном пространстве в файле ibdata1
Физически единое табличное пространство может располагаться в нескольких файлах
Можем выделить отдельные табличные пространства под каждую из таблиц

Изначальна траназкции помещаются в ib_logfile0, ib_logfile1 и затем перегоняются в ibdata1

Если происходит штатная остановка сервера, то транзакции перегоняются из ib_logfile0, ib_logfile1 в ibdata1
Если нешатно, то при следующем старте сервака, транзакции перегоняются из ib_logfile0, ib_logfile1 в ibdata1

Увеличивая размер журнала транзакций можно ускорить вставку записей при штатной работе MYSQL, однако чем больше журнал транзакций, тем медленней будет стартовать сервер

Три режима сохранения журнала транзакций innodb_flush_log_at_trx_commit:
- 0 -- сохранение журнала раз в секунду
- 1 -- сохранение после каждой транзакции
- 2 -- 0 + 1

show variables like 'innodb_flush_log_at_trx_commit';
set global innodb_flush_log_at_trx_commit = 0; -- раз в секунду


Пользоватльские переменные SQL
select @total := count(*) from products; -- создание переменной
select @total; -- обращение к переменной, будет доступна только в текущей сессии

Если в качестве значения переменной передается столбец который содержет множество значений, то переменная получит последнее значение.

Переменные могу определяться с помощью SET
set @last = now() - interval 7 day;

Можно пронумеровать строки в селекте
set @start := 0;
select @start := @start + 1 as id, name from products;

Cистемные переменные:
show variables;
show variables like 'read_buffer_size';

- GLOBAL - глобальные, влияют на весь сервер 
- SESSION - сеансовые, влияют на текуще подключение

При статре сервера происходит инициализация переменных значениями по умолчнию
set global read_buffer_size = 2097152; -- изменение глобальной переменной
set @@global.read_buffer_size = 2097152; -- изменение глобальной переменной

При подключении к серверу сеансовые переменные принимают значения заданные для глобальных переменых
set session read_buffer_size = 2097152;
set @@session.read_buffer_size = 2097152;
set read_buffer_size = DEFAULT;

Временные таблицы:
create temporary table table_name (
    id SERIAL PRIMARY KEY,
    name varchar(255),
    ...
);
Временная таблица автоматически удаляется позавершению соединения с сервером.
Ее имя действительно только в течение данного соединения
create temporary table temp (id int, name varchar(255));
Временные таблицы хранятся во временном табличном пространстве ibtmp1

Динамические запросы
prepare ver from 'select version()';
execute ver;
Живут в течение текущего сеанса
prepare prd from 'select id, name, price from products where catalog_id = ?'; -- параметризованный динамический запрос
set @catalog_id = 1;
execute prd using @catalog_id;
Есть ряд ограничений. Не допускается использование вложенным динамических запросов, а также нескольких запросов. Параметр всегда передает строку, поэтому не получится динамически задать имя таблицы или столбца
drop prepare prd; -- удаление запроса

Представления
Это запрос на выборку которому присваивается уникальное имя и который можно сохранять и удалять из БД как обычную таблицу
Более гибкое управление правами доступа к таблицам. Также можно запретить прямое обращение пользователей к таблицам и разрешить только к представлениям. Также позволяют обеспечить совместимость программ ориентирующихся на старую структуру данных
create view cat as select * from catalogs order by name;
create view cat_reverse (catalog, catalog_id) as select name, id from catalogs;